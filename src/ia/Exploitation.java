package ia;

import java.awt.Point;
import java.util.ArrayList;
import java.util.List;
import java.util.Random;

import bluetooth.BluetoothRobot;
import api.Observable;
import api.Observer;
import model.Direction;
import model.Grid;
import model.Position;
import model.WallState;
import captors.ExtendedMovement;


public class Exploitation implements Observer {

	private Position position;
	private Grid grid;
	private List<Point> path;
	private ExtendedMovement movement;
	
	public Exploitation(Position position,Grid grid,ExtendedMovement movement){
		this.position=position;
		this.grid=grid;
		this.movement=movement;
	}
	
	
	public void solve() {
		Random rand = new Random();
		
		// Tant qu'on est pas à destination
		while (!BluetoothRobot.bt.destination.equals(this.position.getPoint())) {
			// Si destination pas connue alors chemin aléatoire !
			Point destination = new Point(BluetoothRobot.bt.destination);
			if (destination.x == -1)
				destination.x = rand.nextInt(this.grid.getHeight());
			if (destination.y == -1)
				destination.y = rand.nextInt(this.grid.getWidth());
		
			// Résolution vers la destination
			IA ia = null;
			if (BluetoothRobot.bt.id == 0)
				ia = new IA(this.position, BluetoothRobot.bt.otherPosition, this.grid);
			else
				ia = new IA(BluetoothRobot.bt.otherPosition, this.position, this.grid);
			Solution sol = ia.goTo(destination.x, destination.y);
			this.getPath(sol);
			
			while (!this.path.isEmpty() && !BluetoothRobot.bt.conflict){
				Point nextPoint = this.path.remove(0);
				Point begin = this.position.getPoint();
				Direction nextDirection = Direction.getDirectionBetween(this.position.getPoint(), nextPoint);
				this.movement.turn(nextDirection);
				BluetoothRobot.bt.send("NEXT_POS;" + nextPoint.x + " " + nextPoint.y);
				this.movement.straightForward();
				
				//si le robot n'arrive pas à la bonne case
				if (!this.position.getPoint().equals(nextPoint)){
					this.setChanges(begin,this.position.getPoint(),this.position.getDirection());
					BluetoothRobot.bt.send("CONFLICT");
					break;
				}
			}
			
			this.path.clear();
			BluetoothRobot.bt.conflict = false;
		}
	}
	
	
	
	
	//Get the right path according to the ID
	public void getPath(Solution sol){
		if (sol.alonePath != null) {
			if (BluetoothRobot.bt.id==0)
				this.path = sol.alonePath;
			else if (BluetoothRobot.bt.id==1)
				this.path = new ArrayList<Point>();
		} 
		else {
			if (BluetoothRobot.bt.id==0)
				this.path = sol.myCoopPath;
			else if (BluetoothRobot.bt.id==1)
				this.path = sol.otherCoopPath;
		}
	}
	
	
	//Met à jour les murs si on arrive pas à la bonne case
	public void setChanges(Point start, Point dest,Direction dir){
		this.grid.setState(dest.x,dest.y,dir,WallState.Wall);
		int x=start.x, y = start.y, dx = 0, dy = 0;
		switch (dir){
		case NORTH:
			dx = -1;break;
		case SOUTH:
			dx = 1;break;
		case EAST:
			dy = 1;break;
		case WEST:
			dy = -1;break;
		}
		while (dest.x != x && dest.y != y) {
			this.grid.setEmpty(x, y, dir);
			x += dx;
			y += dy;
		}
		this.grid.setWall(x, y, dir);
	}


	@Override
	public void update(Observable o, Object arg) {
		
	}
}
