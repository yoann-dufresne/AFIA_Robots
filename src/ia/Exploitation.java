package ia;

import java.awt.Point;
import java.util.List;
import java.util.Random;

import model.Direction;
import model.Grid;
import model.Position;
import model.WallState;
import bluetooth.BluetoothRobot;
import captors.ExtendedMovement;


public class Exploitation {

	private Position position;
	private Grid grid;
	private List<Point> path;
	private ExtendedMovement movement;
	
	public Exploitation(Position position,Grid grid,ExtendedMovement movement){
		this.position=position;
		this.grid=grid;
		this.movement=movement;
	}
	
	
	public void solve() {
		Random rand = new Random();
		
		IA ia = null;
		if (BluetoothRobot.bt.id == 0)
			ia = new IA(this.position, BluetoothRobot.bt.otherPosition, this.grid);
		else
			ia = new IA(BluetoothRobot.bt.otherPosition, this.position, this.grid);
		
		// Tant qu'on est pas à destination
		while (!BluetoothRobot.bt.destination.equals(this.position.getPoint())) {
			// Si destination pas connue alors chemin aléatoire !
			Point destination = new Point(BluetoothRobot.bt.destination);
			if (destination.x == -1)
				destination.x = rand.nextInt(this.grid.getHeight());
			if (destination.y == -1)
				destination.y = rand.nextInt(this.grid.getWidth());
		
			Solution sol = null;
			if (!BluetoothRobot.bt.computeInProgress) {
				// Select and send path for the local robot (Computer robot)
				BluetoothRobot.bt.send("COMPUTE_PATH");
				sol = ia.goTo(destination.x, destination.y);
				
				if (sol.alonePath != null) {
					this.path = sol.alonePath;
				} else {
					this.path = sol.myCoopPath;
					String request = "COMPUTED_PATH";
					for (Point p : sol.otherCoopPath)
						request += ";" + p.x + ";" + p.y;
					BluetoothRobot.bt.send(request);
				}
			} else {
				// Wait for path (Through the BT)
				sol = new Solution();
				while (true) {
					synchronized (BluetoothRobot.bt.distantPath) {
						if (BluetoothRobot.bt.distantPath == null) {
							try {
								Thread.sleep(100);
							} catch (InterruptedException e) {
								e.printStackTrace();
							}
						} else {
							this.path = BluetoothRobot.bt.distantPath;
							BluetoothRobot.bt.distantPath = null;
							BluetoothRobot.bt.computeInProgress = false;
						}
					}
				}
			}
			
			while (!this.path.isEmpty() && !BluetoothRobot.bt.conflict){
				Point nextPoint = this.path.remove(0);
				Point begin = this.position.getPoint();
				Direction nextDirection = Direction.getDirectionBetween(this.position.getPoint(), nextPoint);
				this.movement.turn(nextDirection);
				BluetoothRobot.bt.send("NEXT_POS;" + nextPoint.x + " " + nextPoint.y);
				this.movement.straightForward();
				
				//si le robot n'arrive pas à la bonne case
				if (!this.position.getPoint().equals(nextPoint)){
					this.setChanges(begin,this.position.getPoint(),this.position.getDirection());
					BluetoothRobot.bt.send("CONFLICT");
					break;
				}
			}
			
			this.path.clear();
			BluetoothRobot.bt.conflict = false;
		}
	}
	
	
	//Met à jour les murs si on arrive pas à la bonne case
	public void setChanges(Point start, Point dest,Direction dir){
		this.grid.setState(dest.x,dest.y,dir,WallState.Wall);
		int x=start.x, y = start.y, dx = 0, dy = 0;
		switch (dir){
		case NORTH:
			dx = -1;break;
		case SOUTH:
			dx = 1;break;
		case EAST:
			dy = 1;break;
		case WEST:
			dy = -1;break;
		}
		while (dest.x != x && dest.y != y) {
			this.grid.setEmpty(x, y, dir);
			x += dx;
			y += dy;
		}
		this.grid.setWall(x, y, dir);
	}
}
