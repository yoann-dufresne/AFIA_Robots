package ia;

import java.awt.Point;
import java.util.ArrayList;
import java.util.List;
import java.util.Random;

import model.Direction;
import model.Grid;
import model.Position;
import model.WallState;
import bluetooth.BluetoothRobot;
import captors.ExtendedMovement;


public class Exploitation {

	private Position position;
	private Grid grid;
	private List<Point> path;
	private ExtendedMovement movement;
	
	
	public Exploitation(Position position,Grid grid,ExtendedMovement movement){
		this.position=position;
		this.grid=grid;
		this.movement=movement;
	}
	
	
	public void solve() {
		Random rand = new Random();
		
		IA1Robot ia = null;
		if (BluetoothRobot.bt.id == 0)
			ia = new IA1Robot(this.position, BluetoothRobot.bt.otherPosition, this.grid);
		else
			ia = new IA1Robot(BluetoothRobot.bt.otherPosition, this.position, this.grid);
		
		Point tmpDest = null;
		
		// Tant qu'on est pas à destination
		while (!BluetoothRobot.bt.destination.equals(this.position.getPoint())) {
			// Si destination pas connue alors chemin aléatoire !
			Point destination = new Point(BluetoothRobot.bt.destination);
			if (destination.x == -1)
				destination.x = rand.nextInt(this.grid.getHeight());
			if (destination.y == -1)
				destination.y = rand.nextInt(this.grid.getWidth());
			
			Solution sol = null;
			if (tmpDest == null)
				tmpDest = destination;
			
			if (!BluetoothRobot.bt.computeInProgress) {
				// Select and send path for the local robot (Computer robot)
				sol = ia.goTo(tmpDest.x, tmpDest.y);
				List<Point> pathToSend = new ArrayList<Point>();
				
				if (sol.alonePath != null) {
					if (sol.aloneRobotID == BluetoothRobot.bt.id){// Attention si plus de deux robots au %2
						this.path = sol.alonePath;
						// Phase 1 
						pathToSend = ia.goBackToAnyCorner(/*(sol.aloneRobotID + 1)%2*/);
						// Phase 2 ou 3 
//						pathToSend = ia.goBackHome((sol.aloneRobotID + 1)%2);
					}
					else{
						// Phase 1
						this.path = ia.goBackToAnyCorner(/*(sol.aloneRobotID + 1)%2*/);
						// Phase 2 ou 3
//						this.path = ia.goBackHome((sol.aloneRobotID + 1)%2);
						pathToSend = sol.alonePath;
						}
				} else if (sol.myCoopPath!=null){
					this.path = sol.myCoopPath;
					pathToSend = sol.otherCoopPath;
				}
				else{
					if (tmpDest.equals(destination))
						tmpDest = null;
					else {
						tmpDest.x = rand.nextInt(this.grid.getHeight());
						tmpDest.y = rand.nextInt(this.grid.getWidth());
					}
					continue;
				}
				
				String request = "COMPUTED_PATH";
				for (Point p : pathToSend)
					request += ";" + p.x + ";" + p.y;
				BluetoothRobot.bt.send(request);
				
			} else {
				// Wait for path (Through the BT)
				sol = new Solution();
				while (true) {
					synchronized (BluetoothRobot.bt.distantPath) {
						if (BluetoothRobot.bt.distantPath == null) {
							try {
								Thread.sleep(100);
							} catch (InterruptedException e) {
								e.printStackTrace();
							}
						} else {
							this.path = BluetoothRobot.bt.distantPath;
							BluetoothRobot.bt.distantPath = null;
							BluetoothRobot.bt.computeInProgress = false;
						}
					}
				}
			}
			
			this.path.remove(0);
			while (!this.path.isEmpty() && !BluetoothRobot.bt.conflict){
				Point nextPoint = this.path.remove(0);
				Point begin = this.position.getPoint();
				Direction nextDirection = Direction.getDirectionBetween(this.position.getPoint(), nextPoint);
				BluetoothRobot.bt.send("DEBUG;turn to " + nextDirection);
				BluetoothRobot.bt.send("DEBUG;current " + this.position.getPoint().x + " " + this.position.getPoint().y);
				BluetoothRobot.bt.send("DEBUG;next " + nextPoint.x + " " + nextPoint.y);
				this.movement.turn(nextDirection);
				BluetoothRobot.bt.send("NEXT_POS;" + nextPoint.x + " " + nextPoint.y);
				this.movement.straightForward();
				
				//si le robot n'arrive pas à la bonne case
				if (!this.position.getPoint().equals(nextPoint)){
					this.setChanges(begin,this.position.getPoint(),this.position.getDirection());
					BluetoothRobot.bt.send("CONFLICT");
					break;
				}
			}
			
			this.path.clear();
			BluetoothRobot.bt.conflict = false;
		}
	}
	
	

	//Met à jour les murs si on arrive pas à la bonne case
	public void setChanges(Point start, Point dest,Direction dir){
		this.grid.setState(dest.x,dest.y,dir,WallState.Wall);
		int x=start.x, y = start.y, dx = 0, dy = 0;
		switch (dir){
		case NORTH:
			dx = -1;break;
		case SOUTH:
			dx = 1;break;
		case EAST:
			dy = 1;break;
		case WEST:
			dy = -1;break;
		}
		while (dest.x != x && dest.y != y) {
			// TODO : ENVOYER PAR BT
			this.grid.setEmpty(x, y, dir);
			x += dx;
			y += dy;
		}
		this.grid.setWall(x, y, dir);
		// TODO : ENVOYER PAR BT
	}
}
